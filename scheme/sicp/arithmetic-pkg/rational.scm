;;;; Rational Number Package

(load-from-path "lib.scm")

(define (install-rational-package)
  ;; internal procedures
  (define (numer x) (car x))
  (define (denom x) (cdr x))
  (define (make-rat n d)
    (define (make-rat-pos n d)
      (let ((g (gcd n d)))
        (cons (/ n  g) (/ d g))))
    (let ((rat (make-rat-pos (abs n) (abs d))))
      (cond ((and (negative? n) (negative? d)) rat)
            ((or (negative? n) (negative? d))
             (set-car! rat (- 0 (car rat)))
             rat)
            (else rat))))
  (define (add-rat x y)
    (make-rat (+ (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (- (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y))
              (* (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (* (numer x) (denom y))
              (* (denom x) (numer y))))
  (define (equal-rat? x y)
    (= (* (numer x) (denom y))
       (* (numer y) (denom x))))
  (define (zero-rat? x)
    (= (numer x) 0))
  (define (print-rat x)
    (display (numer x))
    (display "/")
    (display (denom x))
    (newline))

  ;; interface to rest of system
  (define (tag x) (attach-tag rational-tag x))
  (put 'denom '(rational)
       (lambda (x) (denom (contents x))))
  (put 'numer '(rational)
       (lambda (x) (numer (contents x))))
  (put 'add '(rational rational)
       (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational)
       (lambda (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational)
       (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational)
       (lambda (x y) (tag (div-rat x y))))
  (put 'num-eq? '(rational rational)
       (lambda (x y) (equal-rat? x y)))
  (put 'make 'rational
       (lambda (n d) (tag (make-rat n d))))
  (put '=zero? '(rational) zero-rat?)
  'done)

(define (negate-rat x)
  (make-rat (- 0 (numer x)) (denom x)))             

(define (negative-rat? x)
  (cond ((and (negative? (numer x)) (negative? (denom x))) #f)
        ((or (negative? (numer x)) (negative? (denom x))) #t)
        (else #f)))

(define rational-tag 'rational)
(define (rational? x)
  (eq? (type-tag x) 'rational))
